---
title: 실행 컨텍스트
description: 실행 컨텍스트 설명
category: "javascript"
cover: js.png
date: "2017-03-01"
tags:
  - tag
---

실행가능한 코드를 형상화하고 구분하는 추상적 개념. 실행가능한 코드가 실행되기 위해 필요한 환경이라고 할 수 있다.

**실행 가능한 코드**

- 전역 코드
- eval 코드
- 함수 코드

**실행 가능한 코드에서 실행에 필요한 정보**

- 변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티
- 함수선언
- 변수의 유효범위 ( scope )
- this

## 변수의 유효범위 ( Scope )

변수의 접근성과 생존기간을 의미하는데 변수가 가지고 있는 참조 가능한 범위라고도 할수있겠다.  
Scope는 전역 스코프와 지역 스코프 두가지로 나눌수 있다. 전역 스코프는 전역에서 참조가 가능하지만 지역 스코프는 변수가 정의된 함수 내에서만 참조가 가능하다. 하지만 ES6에 도입된 const, let 키워드는 block-level 스코프를 갖는다.

> 변수는 '선언된 위치'에 의해 스코프를 가지게 된다.

```js
// 선언 위치에의한 변수의 스코프
var x = 10;
function foo() {
  var x = 5;
  bar();
}
function bar() {
  console.log(x); // 이 위치에서는 foo의 x를 참조할수 없다.
}
foo(); //10
```

```js
// 함수레벨 스코프, 블록레벨 스코프
if (true) {
  const x = 10;
}
console.log(x); // Error x is not defined
var y = 20;
function fn() {
  var y = 10;
}
fn();
console.log(y); // 20
```

## this

함수의 호출패턴에 의해 값이 다르게 결정되며 3가지 호출패턴으로 나눌 수 있다.

- 메서드 호출 패턴
- 생성자 호출 패턴
- call, apply 호출 패턴

> 전역에서의 함수 호출 역시 window라는 객체의 메서드이기 때문에 메서드 호출 패턴이라고 할 수 있다.

### 메서드 호출 패턴

메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다.

> 함수객체의 프로토타입( 함수.prototype )도 내부에서 사용된 this는 해당 메서드를 호출한 프로토타입에 바인딩된다.

### 생성자 함수 호출 패턴

기존 함수 앞에 new 키워드를 붙여 함수를 호출하면 생성자 함수로 동작한다.  
생성자 함수로 사용될 함수 이름의 첫 글자는 대문자로 사용하여 일반 함수와 구분하도록 암묵적으로 약속되어있다.

```js
// 첫 글자가 대문자인 함수와, 소문자인 함수 모두 정상 작동한다.
function Fn() {}
var obj1 = new Fn();
function fn2() {}
var obj2 = new Fn2();
```

**생성자 함수의 동작 방식**

1. 빈 객체 생성 및 this 바인딩  
   생성자 함수가 생성되기 직전 빈 객체( 인스턴스 )가 생성되며 생성자 함수 내에서 사용된 this는 이 객체를 가리킨다.
2. this를 통한 빈 객체( 인스턴스 ) 프로퍼티 생성
3. 생성된 객체 반환  
   반환문이 없으면 this가 바인딩한 객체 반환

### call, apply 호출 패턴

this를 명시적으로 특정 객체에 바인딩한다.  
첫 번째 인자로 함수를 실행시킬 컨텍스트를 전달한다.  
두 번쨰 인자는 apply는 배열로 받고 배열의 엘리먼트를 가변 인자 목록으로 전달한다.  
call 함수는 두 번째 인자부터 함수의 매개변수 값으로 전달할 값을 설정한다.

> ES6에서 bind메서드도 추가되었는데 이 메서드는 함수를 호출하지 않는다.

```js
// call, apply를 이용한 this 바인딩
function fn(test, plus) {
  console.log(test + this.name, plus + this.age);
}
function Lee(name, age) {
  this.name = name;
  this.age = age;
}
function Kee(name, age) {
  this.name = name;
  this.age = age;
}
var le = new Lee("lee", 20);
var ke = new Kee("kee", 30);
fn.call(le, "test", 10); // testlee 30
fn.call(ke, "test", 10); // testkee 40
fn.apply(le, ["haha", 5]); // hahalee 25
fn.apply(ke, ["haha", 5]); // hahakee 35
```

## 실행 컨텍스트의 3가지 구성 요소

### Variable Object (VO / 변수객체)

실행에 필요한 변수, 매개 변수, 인수 정보, 함수 선언에 대한 정보가 담겨있다. VO는 전역 컨텍스트에서 생성되는 경우와 함수 컨텍스트에서 생성될때 가리키는 객체가 다르다. 전역 컨텍스트( 전역 코드 )의 경우 **전역객체( Global Object )**를 가리키지만 함수컨텍스트에서는 **활성화객체 ( Active Object )**를 가리키며 활성화 객체는 매개변수, 인수의 정보를 배열의 형태로 담고있는 객체인 arguments Object가 추가된다.

### Scope Chain

중첩된 함수의 스코프 레퍼런스를 차례로 저장하고 있는 개념이다. 즉, 스코프 체인은 참조할 수 있는 VO의 리스트를 가리킨다. 스코프 체인의 맨 앞은 항상 코드가 실행되는 컨텍스트의 변수 객체이며 그다음 순서는 이전에 생성된 변수 객체이며 마지막 순서는 전역 객체이다.

자바스크립트에서 함수는 객체이고 객체는 접근할 수 있는 속성과 자바스크립트 엔진에서 사용되는 접근할 수 없는 내부 속성이 있다. 함수 객체는 [[scope]] 내부속성을 갖고 있는데 이 속성은 함수가 만들어진 스코프를 나타내는 객체의 컬렉션( 함수가 만들어진 시점의 scpoe chain )을 가리킨다.

```js
var x = 1;
function add() {
  var y = 2;
}
/*
  * add함수의 VO객체
  { y: undefined }

  * add함수의 [[scope]]
  { ...window, x: 1 }

  * add함수의 scopeChain
  { y: undefined },
  { ...window, x: 1 }
*/
```

함수 선언 시점에서 EC( 실행컨텍스트 )의 Scope Chain이 함수 객체의 [[scope]] 속성에 복사된다. 함수 add의 EC에서도 식별자 해석에 쓸 자기만의 스코프 체인이 만들어지며 add 함수의 [[scope]] 에 있는 객체로 초기화되고 순서대로 복사된다. 이후 변수 객체가 EC에 생성되며 add함수의 스코프 체인의 맨 앞에 위치한다.

함수를 실행하는 도중 변수가 등장 할때마다 데이터를 어디에 저장할지, 또는 어디에서 가져올지 결정하기 위해 식별자를 해석하는데 이 과정중에 변수와 같은 이름의 식별자를 찾기 위해 EC의 scope chain을 검색한다. 식별자 해석도 조금이라도 컴퓨터 성능에 부담을 주기 때문에 식별자가 scope chain 깊이 있을수록 접근시간이 증가한다. 따라서 함수안에 있는 지역 변수를 가장 빠르게 접근 할 수 있으며 전역 변수는 접근이 가장 느리다.

**Scope Chain의 확장**  
특정 문장( with 문, try-catch 문의 catch 문 )은 스코프 체인 앞부분에 임시로 변수 객체를 만들며 해당 변수 객체는 코드의 실행이 끝나면 사라진다. with 문에서는 해당 객체가 스코프 체인에 추가되며 catch 문에서는 여러 객체를 선언한 변수 객체가 추가된다.

### this

## 실행 컨텍스트의 생성 과정

### 전역 코드로 진입

컨트롤이 EC에 진입하기 이전에 전역 객체가 생성된다. 이후, 컨트롤이 전역 코드로 진입하면 EC가 생성되고 컨텍스트 스택에 쌓인 뒤 EC를 바탕으로 처리가 실행된다.

**처리 과정**

1. 스코프 체인의 생성과 초기화

2. 변수 객체화( Variable Instantiation ) 실행  
   VO에 프로퍼티와 값을 추가하는 것을 의미한다. 변수, 매개변수, 인수, 함수선언을 VO에 추가하여 객체화한다.

   > 실행 순서
   >
   > 1. ( Function Code 일 경우 ) 매개변수가 VO 프로퍼티로 인수가 값으로 설정된다.
   > 2. 함수선언을 대상으로 함수명이 VO 프로퍼티로 함수객체가 값으로 설정된다.
   > 3. 변수선언을 대상으로 변수명이 VO 프로퍼티로 undefined가 값으로 설정된다.

3. 함수 선언처리  
   전역 컨텍스트의 VO에 함수명은 프로퍼티로 함수 객체는 값으로 설정되며 생성된 함수 객체는 [[scope]] 프로퍼티를 갖게 되며 함수 객체가 실행되는 환경을 가리킨다. 따라서 현재 ( 함수가 실행된 컨텍스트의 ) 스코프 체인을 복사한다.  
   [[scope]] 는 자신의 실행환경, 자신을 포함하는 외부 함수와 전역 객체를 가리키는데 이때 외부함수의 실행 컨텍스트가 소멸하여도 [[scope]] 프로퍼티가 가리키는 외부 함수의 실행환경은 파괴되지 않고 참조할 수 있는데 이를 클로저라고 한다.

4. 변수 선언처리  
   세분화하면 선언단계, 초기화 단계, 할당 단계로 나눌 수 있다. 선언 단계에서 VO에 변수를 등록하고 스코프가 참조할 수 있는 대상이 되며 초기화 단계에서는 VO에 등록된 변수를 메모리에 할당하고 undefined로 초기화한다. 할당 단계에서는 실제 값을 할당한다.

5. this value 결정  
   this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다. 함수 호출 패턴에 의해 this에 값이 결정된다.

### 전역 코드 실행

VO에 초기화한 변수의 값이 할당문을 만나 실제 값으로 할당되며 함수 실행문을 만나면 함수 역시 전역 코드의 실행과 같은 과정을 거치며 실행된다. 함수와 전역 코드의 차이는 VO 객체화 과정 중 맨 처음에 매개 변수를 키로 인자를 값으로 하는 부분이 추가된다.

**실행 가능 코드의 실행 순서**

1. 컨트롤이 전역 코드로 진입하기 이전 GO( global Object ) 생성
2. 컨트롤이 전역 코드 진입
3. 전역 코드 실행 전 전역 EC 생성
4. 전역 코드 실행  
   변수로 선언된 VO의 프로퍼티의 **할당문**을 만나면 할당문의 값을 VO의 프로퍼티 값으로 한다. **함수 실행문**을 만나면 VO의 함수 객체를 실행시키고 실행 과정은 전역 코드의 실행과 거의 동일한 순서로 진행된다.  
   함수 EC의 Scope chain은 함수 객체의 [[scope]] 프로퍼티를 복사하고 맨 앞쪽에 컨텍스트의 VO를 넣는다.

> EC 생성 과정
>
> 1. EC의 Scope chain 생성 및 초기화
> 2. 변수 객체 객체화

```js
{
  fnName: function() {},
  vNmae: undefined
};
// 단, 함수의 EC일 경우 매개 변수를 프로퍼티로, 인자를 값으로 하는 동작이 선행 된다.
```

> 3.  this value 결정  
>     this는 최초에 전역 객체를 가리키지만, 함수 호출 패턴에 따라 바인딩 되는 객체가 결정된다. arrow fucntion은 this가 없음으로 제외된다. arrow function은 this를 클로저를 이용해 접근한다.
